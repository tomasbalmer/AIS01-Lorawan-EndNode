# Ghidra Findings — 2025-11-03

- **analysis_date:** 2025-11-03
- **analyzed_by:** reverse session (Ghidra)
- **binary_range:** 0x08000000 - 0x0801502F
- **notes:** references to 0x0801xxxx point to external code not present in current dump

## 1. Context and Scope
- Firmware image available only up to `0x0801502F`.
- Any pointer into `0x0801xxxx` (for example `0x0801FDBc`) belongs to code that is not part of this binary snapshot (likely bootloader or linked libraries).
- When documenting such symbols, mark them as **external / not present in dump**.

## 2. Vector Table Overview
- Vector table resides at `0x08000000`.
- Entries mix direct pointers to handlers inside `0x0800xxxx` and literal data (strings referenced later).

## 3. Reset_Handler Summary
- **Address:** `0x0800F30C` (code inspected from `0x0800F30C` to `0x0800F36C`).
- **Key Globals Initialised:**
  - `r4 = DAT_0800F374 -> 0x20006CC0` (primary `device_state_t` in RAM).
  - `r0 = DAT_0800F378 -> 0x20000118` (boot flags / early runtime flags).
  - `r5 = DAT_0800F37C -> 0x20006D0C` (runtime copy of `device_state_t`).
- **Observed Steps:**
  1. Set boot flags at `0x20000118` (`DAT_0800F378[0..2] = 1`).
  2. Copy multiple fields from `device_state_t` (`0x20006CC0`) into `device_state_runtime` (`0x20006D0C`).
  3. Zero out bytes/words in `ram_config_t` region (`0x20005140`).
  4. Iterate linked list via `*(node + 0x24) = 0; node = *(node + 0x28);` to clear scheduler entries.
  5. Return once RAM initialisation is complete.
- **Conclusion:** Reset performs RAM mirroring and clears scheduler state without calling out-of-range functions.

## 4. RAM Structures

### 4.1 ram_config_t (base `0x20005140`)
- Suggested name: `ram_config_t_20005140`.
- Partial layout extracted:
  - `0x00`: status flags (byte)
  - `0x04`: `uint32_t field_04`
  - `0x08`: `uint32_t field_08`
  - `0x0C`: `uint32_t field_0C`
  - `0x10`: `uint8_t byte10`
  - `0x11`: `uint8_t byte11`
  - `0x12`: `uint8_t byte12`
  - `0x14`: `uint16_t word14`
  - `0x18`: `uint32_t field_18`
  - `0x1C`: `uint32_t ptr_list_head`
  - `0x20`: `uint8_t unk20`
  - `0x21`: `uint8_t unk21`
  - `0x28`: status byte used in scheduler comparisons
  - `0x2D`: flag checked by `FUN_0800F4F4`
  - `0x63`: byte passed to `FUN_0800F5BC`
  - `0xA8`: `uint32_t wake_timer_value` (`DAT_200051E8`)
  - `0xAC`: `uint32_t wake_timer_value_b` (`DAT_200051EC`)
  - `0xB0`: `uint8_t clz_result` (`DAT_200051F0`)
  - `0xB8`: persisted field (`DAT_200051F8`)
- Referenced heavily by `FUN_0800F5BC` and scheduler helpers.

### 4.2 device_state_t (`0x20006CC0`)
- Suggested name: `device_state_t_20006CC0`.
- Partial offsets:
  - `0x00..0x03`: boot flags set by Reset_Handler.
  - `0x24`: copied to `ram_config` by `FUN_0800F4F4` (`field79`).
  - `0x2D`: byte used during sync (`field88`).
  - `0x30`, `0x34`, `0x38`: scheduler/timekeeping words.
  - `0x4C`: embedded sub-structure (22 bytes) mirroring parts of `ram_config_t`.
  - `0x70`, `0x74`, `0x78`: runtime counters touched during reset.
- Mirrors to runtime copy at `0x20006D0C`.

## 5. Function Summaries
- **Reset_Handler (`0x0800F30C`):** RAM initialisation, list clearing, pointer setup.
- **FUN_0800F5BC:** Timer/scheduler guard (recommended alias `check_and_start_timers`).
  - Calls `thunk_FUN_0800B97C`, reads timer values via `FUN_0800D540`, copies results into `0x200051E0/0x200051E4`.
  - Checks `ram_config_t[0x28]` for status `2` before arming timers.
  - Updates timer registers at offsets `0xA8` and `0xAC`; toggles flags in `device_state` (`DAT_20006CBC`).
- **FUN_0800F4F4:** Synchronisation helper (alias `sync_device_state_to_ram`).
  - Invokes `FUN_0800D768` (external helper).
  - Copies `device_state` fields into `ram_config_t` offsets `0x60`, `0x6C`, and updates status bytes `0x5C`, `0x6E`, `0x6F`, `0x29`.
  - If `DAT_20004D69 == 0`, mirrors `ram_config[0x64]` into `DAT_20006AD4`.
- **FUN_0800F454:** Thunk into external function.
  - Loads target from `DAT_0800F464 -> 0x0801FDBC` then branches via `(*target + 0x34)`.
  - Due to address outside current binary, mark as **external dependency**.

## 6. Key Findings
- Two principal RAM structures (configuration and device state) identified with useful offsets.
- Reset handler focuses on RAM mirroring and scheduler reset.
- Scheduler helpers (`FUN_0800F5BC`, `FUN_0800F4F4`) manage timers and state snapshots.
- External dependency at `0x0801FDBC` cannot be analysed without additional firmware image.

## 7. Scheduler & Duty Cycle Functions

### Reset_Handler (`0x0800F30C`)
- Role: initialise global context (`g_ctx`, `g_ptr_ram_config`) prior to scheduler.
- Actions: copy base configuration, clear RAM structures and linked lists.
- Impact: prepares RAM; no state-machine logic yet.

### check_duty_or_join_gate (`0x0800F308`)
- Role: reset duty-cycle/join controllers.
- Behaviour: mirrors Reset_Handler’s sequence for RAM areas tied to TX/join gating; no radio calls.
- Impact: restores timers/flags regulating access to TX or join.

### compute_transmit_offset_or_join_window (`0x0800F380`)
- Role: evaluate whether transmissions or join retries are allowed.
- Behaviour: reads offsets around `DAT_0800F3D0` (+0x22, +0x23), compares time windows.
- Returns: `0` (block) or `1` (allow).
- Impact: gate condition invoked by the scheduler before attempting TX/join.

### scheduler_loop (`0x0800FD2C`)
- Uses context at `0x20005140` (`g_ctx`) plus time/radio/timer globals.
- Flow (summary):
  1. Boot/init exit if `g_ctx[0x12] == -1` → return `9`.
  2. Join gate via `compute_transmit_offset_or_join_window` → return `8` if blocked.
  3. TX/RX path building payloads via MAC helpers.
  4. Idle → `compute_next_idle_delay(g_ctx[0x20])` → `timer_set_next_wakeup` / `timer_start`.
- Related helpers:
  - `check_duty_or_join_gate` @ `0x0800F308`.
  - `compute_transmit_offset_or_join_window` @ `0x0800F380`.
  - `compute_next_idle_delay` near `0x0800FCA*`.
  - `FUN_0800F28C`: timing/slot computation (not the state switch itself).

### Opcode Table External Entry
- Table entry at `0x08014B60` points to `0x080205EA` — outside current binary (mark as external dependency).

## 8. Documentation Integration Notes
- Update memory map to state dump limit (`0x0801502F`) and mark `0x0801xxxx` references as external.
- Extend initialisation sequence documentation with Reset_Handler steps listed above.
- Add ram_config_t and device_state_t layouts to the RAM data model chapter.
- Expand call graph with: Reset_Handler -> FUN_0800F5BC -> FUN_0800F4F4 -> FUN_0800F454 (external).
- Record outstanding action: acquire additional binary covering `0x0801xxxx` to resolve external thunk and opcode handler at `0x080205EA`.
