# Ghidra Findings — 2025-11-03

- **analysis_date:** 2025-11-03
- **analyzed_by:** reverse session (Ghidra)
- **binary_range:** 0x08000000 - 0x0801502F
- **notes:** references to 0x0801xxxx point to external code not present in current dump

## 1. Context and Scope
- Firmware image available only up to `0x0801502F`.
- Any pointer into `0x0801xxxx` (for example `0x0801FDBc`) belongs to code that is not part of this binary snapshot (likely bootloader or linked libraries).
- When documenting such symbols, mark them as **external / not present in dump**.

## 2. Vector Table Overview
- Vector table resides at `0x08000000`.
- Entries mix direct pointers to handlers inside `0x0800xxxx` and literal data (strings referenced later).

## 3. Reset_Handler Summary
- **Address:** `0x0800F30C` (code inspected from `0x0800F30C` to `0x0800F36C`).
- **Key Globals Initialised:**
  - `r4 = DAT_0800F374 -> 0x20006CC0` (primary `device_state_t` in RAM).
  - `r0 = DAT_0800F378 -> 0x20000118` (boot flags / early runtime flags).
  - `r5 = DAT_0800F37C -> 0x20006D0C` (runtime copy of `device_state_t`).
- **Observed Steps:**
  1. Set boot flags at `0x20000118` (`DAT_0800F378[0..2] = 1`).
  2. Copy multiple fields from `device_state_t` (`0x20006CC0`) into `device_state_runtime` (`0x20006D0C`).
  3. Zero out bytes/words in `ram_config_t` region (`0x20005140`).
  4. Iterate linked list via `*(node + 0x24) = 0; node = *(node + 0x28);` to clear scheduler entries.
  5. Return once RAM initialisation is complete.
- **Conclusion:** Reset performs RAM mirroring and clears scheduler state without calling out-of-range functions.

## 4. RAM Structures

### 4.1 ram_config_t (base `0x20005140`)
- Suggested name: `ram_config_t_20005140`.
- Partial layout extracted:
  - `0x00`: status flags (byte)
  - `0x04`: `uint32_t field_04`
  - `0x08`: `uint32_t field_08`
  - `0x0C`: `uint32_t field_0C`
  - `0x10`: `uint8_t byte10`
  - `0x11`: `uint8_t byte11`
  - `0x12`: `uint8_t byte12`
  - `0x14`: `uint16_t word14`
  - `0x18`: `uint32_t field_18`
  - `0x1C`: `uint32_t ptr_list_head`
  - `0x20`: `uint8_t unk20`
  - `0x21`: `uint8_t unk21`
  - `0x28`: status byte used in scheduler comparisons
  - `0x2D`: flag checked by `FUN_0800F4F4`
  - `0x63`: byte passed to `FUN_0800F5BC`
  - `0xA8`: `uint32_t wake_timer_value` (`DAT_200051E8`)
  - `0xAC`: `uint32_t wake_timer_value_b` (`DAT_200051EC`)
  - `0xB0`: `uint8_t clz_result` (`DAT_200051F0`)
  - `0xB8`: persisted field (`DAT_200051F8`)
- Referenced heavily by `FUN_0800F5BC` and scheduler helpers.

### 4.2 device_state_t (`0x20006CC0`)
- Suggested name: `device_state_t_20006CC0`.
- Partial offsets:
  - `0x00..0x03`: boot flags set by Reset_Handler.
  - `0x24`: copied to `ram_config` by `FUN_0800F4F4` (`field79`).
  - `0x2D`: byte used during sync (`field88`).
  - `0x30`, `0x34`, `0x38`: scheduler/timekeeping words.
  - `0x4C`: embedded sub-structure (22 bytes) mirroring parts of `ram_config_t`.
  - `0x70`, `0x74`, `0x78`: runtime counters touched during reset.
- Mirrors to runtime copy at `0x20006D0C`.

## 5. Function Summaries
- **Reset_Handler (`0x0800F30C`):** RAM initialisation, list clearing, pointer setup.
- **FUN_0800F5BC:** Timer/scheduler guard (recommended alias `check_and_start_timers`).
  - Calls `thunk_FUN_0800B97C`, reads timer values via `FUN_0800D540`, copies results into `0x200051E0/0x200051E4`.
  - Checks `ram_config_t[0x28]` for status `2` before arming timers.
  - Updates timer registers at offsets `0xA8` and `0xAC`; toggles flags in `device_state` (`DAT_20006CBC`).
- **FUN_0800F4F4:** Synchronisation helper (alias `sync_device_state_to_ram`).
  - Invokes `FUN_0800D768` (external helper).
  - Copies `device_state` fields into `ram_config_t` offsets `0x60`, `0x6C`, and updates status bytes `0x5C`, `0x6E`, `0x6F`, `0x29`.
  - If `DAT_20004D69 == 0`, mirrors `ram_config[0x64]` into `DAT_20006AD4`.
- **FUN_0800F454:** Thunk into external function.
  - Loads target from `DAT_0800F464 -> 0x0801FDBC` then branches via `(*target + 0x34)`.
  - Due to address outside current binary, mark as **external dependency**.

## 6. Key Findings
- Two principal RAM structures (configuration and device state) identified with useful offsets.
- Reset handler focuses on RAM mirroring and scheduler reset.
- Scheduler helpers (`FUN_0800F5BC`, `FUN_0800F4F4`) manage timers and state snapshots.
- External dependency at `0x0801FDBC` cannot be analysed without additional firmware image.

## 7. Scheduler & Duty Cycle Functions

### Reset_Handler (`0x0800F30C`)
- Role: initialise global context (`g_ctx`, `g_ptr_ram_config`) prior to scheduler.
- Actions: copy base configuration, clear RAM structures and linked lists.
- Impact: prepares RAM; no state-machine logic yet.

### check_duty_or_join_gate (`0x0800F308`)
- Role: reset duty-cycle/join controllers.
- Behaviour: mirrors Reset_Handler’s sequence for RAM areas tied to TX/join gating; no radio calls.
- Impact: restores timers/flags regulating access to TX or join.

### compute_transmit_offset_or_join_window (`0x0800F380`)
- Role: evaluate whether transmissions or join retries are allowed.
- Behaviour: reads offsets around `DAT_0800F3D0` (+0x22, +0x23), compares time windows.
- Returns: `0` (block) or `1` (allow).
- Impact: gate condition invoked by the scheduler before attempting TX/join.

### scheduler_loop (`0x0800FD2C`)
- Uses context at `0x20005140` (`g_ctx`) plus time/radio/timer globals.
- Flow (summary):
  1. Boot/init exit if `g_ctx[0x12] == -1` → return `9`.
  2. Join gate via `compute_transmit_offset_or_join_window` → return `8` if blocked.
  3. TX/RX path building payloads via MAC helpers.
  4. Idle → `compute_next_idle_delay(g_ctx[0x20])` → `timer_set_next_wakeup` / `timer_start`.
- Related helpers:
  - `check_duty_or_join_gate` @ `0x0800F308`.
  - `compute_transmit_offset_or_join_window` @ `0x0800F380`.
  - `compute_next_idle_delay` near `0x0800FCA*`.
  - `FUN_0800F28C`: timing/slot computation (not the state switch itself).

### Opcode Table External Entry
- Table entry at `0x08014B60` points to `0x080205EA` — outside current binary (mark as external dependency).

## 8. Downlink Opcode Table Findings (2025‑11‑03 Session)
- **Table base:** `0x08014ABC`; at least 16 DWORD entries (`handler_t *`).
- **Entry structure:** contiguous 32-bit pointers/values indexed by opcode.
- **Known entries:**

| Index | Value | Meaning |
|-------|-------|---------|
| 0 | `0x0800D124+1` | `LAB_0800D124` handler stub |
| 1 | `0x0800D101` | data reference |
| 2 | `0x00000007` | constant |
| 3 | `0x20004B08` | pointer to RAM struct |
| 8 | `0xC8010001` | encoded flags |
| 9 | `0x080121A8+1` | end of `FUN_08012118` |
|10 | `opcode_handler_flag_and_timer+1` | sets flag & timer |
|11 | `opcode_validator_memcmp+1` | payload validator |
|12 | `0x0801220F` | literal ':' |
|13 | (string) " Delay between the end of the Tx..." | diagnostic text |
|14 | `opcode_parse_uint+1` | dispatcher entry |
|15 | `0x080120B5` (`'W'`) | constant |
|16 | `0x00005566` | signature bytes ('Uf') |
|17–49 | `0x00000001` | feature flags |
|50–59 | `0x00000000` | padding / unused |
|60 | `0x080205EA` | external handler (calibration acknowledgement) |
|61–63 | mixed (`0x38`, `0xFF`, `0x1F`, …) | arguments for external handler |

- **Key helpers (confirmed):**
  - `opcode_handler_flag_and_timer` (`0x08011FE1`): sets `unaff_r4[3] = 0x02`; arms timer located at `DAT_080120B8` → `0x20006834`.
  - `opcode_validator_memcmp` (`0x080121E0`): compares payload bytes with data around offset `0x70`; branches to `LAB_08012226` on mismatch.
  - `opcode_parse_uint` (`0x080123E0`): main dispatcher; loads payload pointer from `0x2000013C`, validates opcode, invokes handler via table at `DAT_080123DC` (`0x0802199D`).
  - `LAB_080122B4`: core dispatch loop; handles masking of invalid markers, performs direct call through loaded handler pointer.
  - `FUN_08012118`: payload copy routine referenced by entry 9.
- **Dispatcher behaviour (pseudo):**
  ```c
  opcode = payload[0];
  if (opcode == 0 || opcode > 0x24) return;
  handler = handler_table[opcode];
  if (opcode_validator_memcmp(payload, ...) == 0)
  {
      handler(payload);
  }
  ```
- **Related globals:**
  - `DAT_080120B8` → `0x20006834` (timer handle)
  - `DAT_080120C0` → `0x200058D4` (parameter for `FUN_0800D768`)
  - `DAT_080123DC` → `0x0802199D` (opcode table base)
  - `DAT_080123F4` → `0x2000013C` (payload buffer pointer)
- **Pending items:**
  1. Expand table beyond first 16 entries (`0x08014B00–0x08014B80`).
  2. Resolve external handler at `0x080205EA`.
  3. (✓) Trace calibration flow (`FUN_00003060`) for payload/flag documentation.
  4. (✓) Cross-check CRC/storage layout via `FUN_00003030`.

## 9. Calibration / Configuration Apply Engine
- **Core routines:** `FUN_08003030` (peripheral select), `FUN_08003060` (pending/apply bitfields), `FUN_080030D4` (ready loop), `FUN_080030E8` (commit), `FUN_0800D100` (opcode handler), `opcode_validator_memcmp` (`0x080121E0`).
- **Payload buffer (`0x20004B08`):** `cmd` (0/query, 1/apply) at `0x00`, `flags` `0x01`, `param` `0x04`, `value` `0x10`, `apply_flag` `0x18`.
- **Process:**
  1. Downlink copied to `0x20004B08` and mirrored at `0x20004D98`.
  2. Query path (`cmd==0`) leverages `FUN_08003030/060`; apply path (`cmd==1`) calls `FUN_080030E8`.
  3. `FUN_080030D4` waits for `0x4001D000 & 0xF == 0xF`; bit `0x20` at `0x40000000+0x24` toggled to enable hardware block.
  4. Success acknowledged through `FUN_0800BC5C(0x8B)` (uplink/AT response).
- **Flags:** pending nibbles at `[ctx+0x38/0x3C/0x40]`, apply busy flag `[ctx+0x18]`, hardware enable bit `0x20`.
- **Integrity:** `opcode_validator_memcmp` compares mirrored configuration; no CRC polynomial observed.
- **Peripherals touched:** `0x4001F000`, `0x4001FC00`, `0x4001D000`, `0x40000024`.
- **Status:** calibration engine fully mapped; only outstanding dependency remains external handler at `0x080205EA`.

## 10. Documentation Integration Notes
- Update memory map to state dump limit (`0x0801502F`) and mark `0x0801xxxx` references as external.
- Extend initialisation sequence documentation with Reset_Handler steps listed above.
- Add ram_config_t and device_state_t layouts to the RAM data model chapter.
- Expand call graph with: Reset_Handler -> FUN_0800F5BC -> FUN_0800F4F4 -> FUN_0800F454 (external).
- Record outstanding action: acquire additional binary covering `0x0801xxxx` to resolve external thunk and opcode handler at `0x080205EA`.
- Map AT response strings (`OK`, `AT_ERROR`, calibration messages) to ensure parity with Dragino tools.
